#  조합 만들기

[LV.2 소수 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/42839?language=java)   

해당 문제는 숫자로 이루어진 문자열이 주어질 때, 해당 문자열로 만들 수 있는 정수 중 소수인 것을 찾는 문제이다.

나는 아무런 생각없이 주어진 문자열에서 하나씩 꺼내서 숫자 조합을 만들고 소수를 판별하면 해결이 되겠다 싶은 생각이 들어서 무작정 중첩 반복문을 작성하였다.   

예제 문제를 확인해보니 "011"이라는 문자열이 주어질 때 조합 가능한 수 중 소수인 것들을 확인하고 바로 코드를 작성했다.   
하지만 내가 무시한 부분이 있었다. 조건에서 특정 인덱스의 문자를 반복해서 사용하면 안되는 점이 있었다.   
예제에서 문자열이 "011"이여서 11,101,110과 같이 1을 중복해서 수를 만들 수 있었지, 1이 하나만 있으면 방금 전과 같이 1을 중복 사용이 불가능하다.

그래 좋다! 이러한 제약 정도는 괜찮다라고 생각해서 기존에 작성한 중첩 반복문을 사용하면 되겠다. 라고 생각을 했다.

하지만 주어지는 문자열의 길이는 최대 7자리의 문자열이 주어지는다. 그러면 과연 반복문을 7번 중첩해서 작성해야 하나? 라는 생각이 들었다.

지금까지 LV.2 미만의 문제들만 풀어서 그런지 아니면 제대로 공부를 하지 않아서 그런지 뭔가 쉬운 문제같이 느껴지지만 실상은 나의 느낀점과 달리 조금 어렵다고 생각이 들었다.

왜 그러한 생각이 들었는지 문제를 해결하고 느꼈다.  그 이유는 생각의 폭이 넓지 못 한것이다. 

```java
String 문자열 = "1234";

for(char 문자 : 문자열.toCharArray()){
    for
        for
        ...
        }
```
지금까지 문제를 해결 했던 방법인 중첩 반복문을 고수했다.   
이러한 방식의 단점은 이미 사용한 문자를 또 사용한 조합이 탄생하게 된다 점이 있다.   

중복 사용한 문자는 어떻게 제거를 할 것이가??   

조합된 문자열을 짤라서 하나씩 검사를 할 것인가? 아니면 사용한 인덱스를 체크를 해서 중복 사용이 없도록 할 것이가?   

좋다. 후자의 방법이 좀 더 좋을 것이다.

후자의 방법을 생각했을 때, 처음에 List를 만들어서 특정 인덱스의 문자를 사용 했을 떄 해당 인덱스를 추가를 하고, 
새로운 조합을 할 때 List에서 모든 값을 제거하여 다시 추가하는 방법을 적용했다. 하지만 이러한 방법은 뭔가 이상하다고 생각이 들었다.

그래서 다른 방법으로 `boolean[]`을 선언하고 주어진 문자열과 동일한 크기의 배열을 만들어서 체크를 했다.

여기까지는 예제 1번에 대해서 적용 가능한 코드를 구현 했다.

그런데 문제에서 주어지는 문자열의 길이 1에서 7까지의 길이를 갖는 문자열이 주어진다. 그러면 내가 구현한 코드에 있어서 주어진 상황에 유동적으로 사용하기 힘들어진다.
나는 수종적인 코드를 작성한 것이다. 그래서 이를 해결하기 위해 재귀 함수를 사용했다.
```java
    private void generateCombinations(String numbers, String current, boolean[] visited, Set<Integer> primes) {
        if (!current.isEmpty()) {
            int num = Integer.parseInt(current);
            if (isPrime(num)) {
                primes.add(num);
            }
        }

        for (int i = 0; i < numbers.length(); i++) {
            if (!visited[i]) {
                visited[i] = true;
                generateCombinations(numbers, current + numbers.charAt(i), visited, primes);
                visited[i] = false;
            }
        }
    }
```

기존의 다소 딱딱해 보였던 중첩 반복문 대신 각 상황에 따라 알아서 반복하여 문자열을 만들 수 있게 되었다.

앞으로 내 생각만을 고집하지말고, 좀 더 넓게 생각을 해야겠다.

[완성한 코드](https://github.com/jae9380/Coding_Test-By.Mac-/blob/main/Java/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/42839.%E2%80%85%EC%86%8C%EC%88%98%E2%80%85%EC%B0%BE%EA%B8%B0/%EC%86%8C%EC%88%98%E2%80%85%EC%B0%BE%EA%B8%B0.java)