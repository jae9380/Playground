# 재귀적 탐색

## [유사 칸토어 비열 Lv.2](https://school.programmers.co.kr/learn/courses/30/lessons/148652)   

처음에는 해당 문제를 읽고 완벽한 이해는 불가능 했다. 하지만 다시 자세히 읽어보니 이해를 했었다.   

조건을 보면 0번 째 유사 칸토어 비트열은 `1`이다. 그리고 다음으로 올 비트열은 이전의 비트열에서 "1"은 "11011"로, "0"은 "00000"으리 치환을 하면 된다.    

|$n$|bit|$n$|bit|
|--|--|--|--|
|0|1|3|11011110110000011011110111101111011000001101111011<br>0000000000000000000000000<br>11011110110000011011110111101111011000001101111011|
|1|11011|4|1101111011000001101111011...|
|2|1101111011000001101111011|5|1101111011000001101111011...|

위 표 처럼 나타날 것이다.   
($n$의 값이 조금만 커져도 이를 나타내기에는 조금 벅차다고 느낀다...)    

이러한 비트열이 있을 때 `long`타입의 변수 `l`, `r`이 주어질 때 `l`번 째 부터 `r`까지의 범위에서 "1"의 수를 반환하면 되는 문제이다.   

---

처음에는 $n$이 주어질 때 해당 비트열을 생성하여 주어진 범주에서 직접 카운트를 할 생각이였다. 그래서 직접 하면서 이 방밥은 아니라고 생각을 했다.   

그래서 직접 규칙성을 찾아서 해결을 할 생각이였다.

$n=2$일 경우 비트열을 보자.
```
11011 11011 00000 11011 11011
```
일단 바로 확인이 되는 규칙은 각 칸의 3번 째 값은 무조건 0이다.

다음으로 $n=3$일 경우
```
11011 11011 00000 11011 11011 11011 11011 00000 11011 11011 00000 00000 00000 00000 00000 11011 11011 00000 11011 11011 11011 11011 00000 11011 11011
```
여기도 각 3번 째 값은 0이라는 것을 확인 가능하다.   

전체적인 비트열의 길이가 $\times$ 5 씩 커지고 있다. 이를 바탕으로 비트 더미를 5개를 기준으로 표시를 해보았다.
```
11011 11011 00000 11011 11011 
11011 11011 00000 11011 11011 
00000 00000 00000 00000 00000 
11011 11011 00000 11011 11011 
11011 11011 00000 11011 11011
```
`l`위치의 비트 값은 `l-1`인덱스의 값이다. 그런데 지금 $n=3$일 경우 예제 비트열로 규칙을 수식화 하기에는 0이 연속적으로 나타내는 곳은 어떻게 정의를 해야 하는지 솔직히 조금 그렇다...   

하지만 
> ## 길이가 $\times$ 5 씩 커지고 있다.   
이 부분이 핵심 포인트라고 생각이 된다. 그래서 `l`의 크기가 5 이상으로 주어질 때, `l`의 값을 $\div$ 5를 통해 초기의 상태로 되돌려서 계산을 하면 되겠지? 라는 생각이 들어서 재귀 함수를 이용할 것이다. 

```java
boolean func(long l) {
    // base case
    return check(l / 5);
}
```

그리고 `l`의 크기가 5 이하일 경우, index 2가 아닐 경우는 비트는 1이다.    
그리고 하위 단계에서 상위 단계로 가면서 인덱스 2 위치에 있을 경우 해당하는 값은 0이라는 점을 이용하여 두가기 조건을 추가하자.   
(여기서 하위 단계에서 상위 단계로 간다는 것은 $n$의 값이 작아지는 것을 의미)

```java
// 호출 시 인덱스 계산을 위해 l-1의 값으로 호출 할 예정
boolean func(long l) {
    if(l<5 && l!=2) return true;
    if((l - 2) % 5 == 0) return false;
    return check(l / 5);
}
```


이렇게 되면 $l != 2$ 조건은 `l`이 0~4의 값 중 2가 아니면 ‘1’의 값을 갖고 있기에 `true`반환 한다.    

반면, `false`일 경우 다음 조건으로 현재 인덱스 l이 5로 나누었을 때 2의 위치에 있는지 확인한다.   

예를 들어, 유사 칸토어 비트열은 `1` -> `11011`-> `1101111011` -> ...로 생성되므로, l이 각 단계에서 2의 위치에 해당하면 ‘0’입니다.
따라서 $(l - 2) \% 5 == 0$ 조건을 만족하면 ‘0’이므로 false를 반환합니다.

해당 풀이 방법으로 시간 복잡도는 $O(log_5(n))$으로 해결이 된다.   

이는 `func` 함수에서 매번 인덱스 l을 5로 나누기 때문에, 전체 탐색 깊이는 $log_5(n)$이 됩니다.   

주어지는 [l, r] 구간을 순회하며 함수를 호출하기에 전체 시간 복잡도는 $O((r - l + 1) \times log_5(n))$으로, 구간의 크기와 탐색 깊이에 비례합니다.   

유사 칸토어 비트열의 전체 길이는 $5^n$이지만, 실제로 비트열을 생성하지 않고도 원하는 구간의 값을 확인할 수 있으므로 공간 복잡도는 $O(1)$에 가깝게 해결이 가능하다.   


**분할 정복 기반의 재귀적 탐색을 바탕으로 보다 쉽게 해결이 가능했다.**   


물론 해당 문제는 다른 방식으로도 해결 가능하다.   

다른 방법을 찾아봤을 때, `DFS`알고리즘을 사용하는 경우 또한 봤다.   

그럼 만약 `DFS`로 해결 했다고 가정할 때 성능에 있어서 어떠한 차이가 있는지 GPT선생에게 물어보았다. 

> ### GPT 왈
>1. 문제 분석: 재귀적 탐색 (Divide and Conquer Approach)
>현재 사용된 check 함수는 다음과 같은 규칙을 이용하여 효율적으로 특정 인덱스가 ‘1’인지 ‘0’인지를 판단합니다:
> - 각 단계에서 현재 구간을 5등분하고, 가운데 구간이 ‘0’인 것을 먼저 확인.
> - 해당 구간이 아닌 경우, 상위 단계로 재귀적으로 거슬러 올라가며 확인.
> - $O(log_5(n))$의 시간 복잡도로 각 인덱스에 대해 ‘1’인지 ‘0’인지 확인.
> <br>
> 2. DFS(Depth-First Search) 접근법
> - DFS 방식으로 이 문제를 해결하려면, 유사 칸토어 비트열을 트리 구조로 생각하고 각 노드가 1 또는 0을 나타낸다고 가정할 수 있습니다. 전체 비트열을 재귀적으로 탐색하면서 ‘1’의 개수를 카운트합니다.   
> <br>
> DFS를 사용한 기본적인 방법:    
>   1.현재 구간의 중앙(3번째 위치)이 0인지 확인.   
>   2. 왼쪽 하위 구간과 오른쪽 하위 구간을 재귀적으로 탐색.   
>   3. 원하는 구간에 도달하면 해당 구간 내의 ‘1’의 개수를 카운트.   
> <br>
> 3. 두 접근 방식의 성능 비교
> <br>
>    1. 시간 복잡도:   
>     - 재귀적 탐색 (Divide and Conquer): O((r - l + 1) * log_5(n))
>     - DFS: O(5^n)
>    2. 공간 복잡도:
>     - 재귀적 탐색 (Divide and Conquer): O(1) (상수 공간만 사용)
>     - DFS: O(5^n) (모든 노드를 저장하거나 탐색할 경우)
><br>
> 4. 구체적인 성능 차이
><br>
> - **n = 20**일 때, 유사 칸토어 비트열의 전체 길이는 5^20이 됩니다. 이는 약 **95경(9.5 × 10^13)**의 길이로, 실제로 이 비트열을 생성하거나 전체를 탐색하는 것은 불가능합니다.
> - 반면, Divide and Conquer 방식을 사용하면, 특정 구간에 대해 상위 단계만을 추적하므로 매우 빠르게 결과를 얻을 수 있습니다.
> - DFS는 구간에 상관없이 전체 비트열을 트리 구조로 탐색할 수밖에 없으므로, 매우 비효율적이며 실행 시간이 급격하게 증가할 수 있습니다.
><br>
> ### 결론
> 재귀적 탐색 및 분할 정복 방식을 사용하면 문제의 비트열을 실제로 생성하지 않고도 특정 구간의 값을 효율적으로 계산할 수 있습니다. 반면 DFS 방식은 비트열의 각 노드를 탐색해야 하므로 n 값이 커질수록 비효율적입니다.
