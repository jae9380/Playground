# [CS] 인덱스

## 인덱스

인덱스는 데이터베이스 테이블에 대하여 검색 속도를 향상시켜주는 자료구조이다.

일상에서의 비슷한 예제로는 단어사전을 생각하면 쉽다. 예를 들어서 특정한 자음 또는 알파벳으로 시작하는 단어를 찾을려고 한다.
해당 단어를 찾기위해서 모든 페이지를 확인할 필요없이 찾고자 하는 부분의 색인에서 찾으면 보다 빠르고 편하게 찾을 수 있다.
데이터베이스에서 `index`가 이러한 기능을 담당한다.

특정 컬럼에 인덱스를 생성하게 된다면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장이 된다.
이렇게 인덱스가 생성이 되었다면 퀴리문 작성 시 `where`문으로 조건을 추가하는 등 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수가 있다.
만약 인덱스를 타게 된다면

> Optimizer
> <br>
> SQL 쿼리를 가장 효율적으로 실행할 방법을 경정해주는 데이터베이스 엔진의 구성 요소이다.
> <br>
> 역활

- 여러개의 실행 계획 중에서 가장 적은 비용이 들어가는 계획을 선택하여 실행을 한다.
  주요 기능
- 각 싱행 계확의 비용을 계산하여 비교한다. 비용은 CPU사용량과 I/O 작업량 등을 기준으로 평가 된다.
- 테이블의 크기, 인덱스의 분포, 데이터 분포 등의 통계 정보를 활용하여 최적의 계획을 선택한다.

## 종류

인덱스의 종류에 들어가기 전에 간단하게 `이진 트리`에 대하여 알아보고 넘어가야 `B Tree`에 대하여 쉽게 이해할 수 있다.

> 이진 트리

`B Tree`는 이진 트리에서 잘전되어 모든 리프노드들이 동일한 레벨을 갖도록 자동으로 밸런스를 맞춰 균형을 갖는 트리의 확장판이다.

`이진 트리` 각각의 상위 노드가 최대 슬하의 두 개의 자식 노드를 갖는 구조이다.

![이진 트리](<이진 트리.png>)

이진트리는 형태에 따라 여러 종류가 있다.

(일단은 이러한 종류가 있다고 알아만 보고 나중에 자세히 알아보겠다.)

![이진 트리의 종류](<이진 트리의 종류.png>)

### B-트리 인덱스 (B-tree Index)

가장 일반적으로 사용되는 인덱스의 타입이다.

이는 이진 트리와의 차이점은 하나의 노드에 많은 정보를 갖거나, 두 개 이상의 자식 노드를 취할 수 있다.  
하나의 노드에 여러 정보를 담게되며, 여러 자식을 가질 수 있게 되면서 차수라는 개념이 나타났다.

> 차수
> <br>
> "차수"라는 개념은 `B-Tree`의 구조와 성능을 결정하는 중요한 요소 중 하나이다. 차수는 아래와 같은 두 가지의 방식에 의하여 정의가 된다.
> <br>

- 최소 차수 (Minimum Degree, $t$)
  `B-Tree`의 최소 차수는 $t$로 나타내며, 각각의 노드가 가질수 있는 최소한의 자식 수와 관련이 있다.
  `B-Tree`의 최소 차수 $t$에 따라 특성을 갖는다.
  - 각 내부 노드는 최소한 $t$개의 자식을 가져야 한다. 그러나 뤁 노드는 이 규칙에서 제외가 되며, 최소한 두 개의 자식이 있으면 된다.
  - 각 내부 노드는 최대 $2t$개의 자식을 가질 수 있다.
  - 각 노드는 최소한 $t - 1$개의 키를 가져야 한다. (루트는 최소 1개)
  - 각 노드는 최대 $2t - 1$개의 키를 가질 수 있다.
    <br>
- 최대 차수
  `B-Tree`의 최대 차수는 각 노드가 가질 수 있는 최대 자식 수로, 보통 $2t$로 정의가 된다. 여기서는 $t$는 최소 차수이다.
  <br>
  이러한 규칙은 균형을 유지하는데 중요하다. 예를 들어서 $t$=3인 `B-Tree`에서 각 노드가 최소 2개의 키와 최대 5개의 키를 가질 수 있으며, 각 내부 노드는 최소 3개의 자식과 최대 6개의 자식을 가질 수 있다.
  <br>
  `B-Tree`에서 차수는 트리의 높이를 낮추고, 디스크 접근을 줄이며, 삽입, 삭제, 검색 등의 연산을 효율적으로 수행하는데 중요한 역활을 한다. 따라서, 차수는 `B-Tree`의 성능과 저장 구조과 저장 구조를 결정하는데 핵심적인 매개변수이다.

해당 인덱스는 정렬된 데이터를 유지하고, 검색, 삽입, 삭제 작업에서 $O(log n)$의 성능을 제공한다.
주로 범위 검색에 유리하다.

각각의 노드 내 데이터들은 항상 정렬된 상태인 것이 특징이며, 데이터와 데이터 사이의 범위를 이용하여 자식 노드를 갖는다. (자식 노드의 수는 n+1개)
또한, 하나의 노드에서는 여러 갸의 키를 가질수 있으며 키에 해당하는 데이터 또한 같이 갖는다.

### B+트리 인덱스 (B+tree Index)

해당 인덱스는 `B-tree Index`의 변형된 구조이다. 그렇기 때문에 몇가지의 부분은 비슷하지만 차이점이 존재한다.  
해당 인덱스는 균형 잡힌 이진 검색 트리이다. `B-tree Index`에 비하여 더 많은 키를 가질 수 있다.

`B+tree Index`는 `B-tree Index`와 달리 내부 노드와 단말 노드로 구분이 된다. `B+tree Index` 모든 데이터는 단말 노드에서만 저장이 가능하며, 내부 노드에서는 검색을 위한 인덱스만 저장이 된다.

### 해시 인덱스 (Hash Index)

`K-V` 쌍을 기반으로 데이터의 위치를 빠르게 찾을 수 있다.
정확한 값 검색에 뛰어나지만 반대로 범위 검색에는 적합하지 않다.
MySQL에서는 MEMORY 엔진에서 주로 사용된다.

### 비트맵 인덱스 (Bitmap Index)

이는 데이터 값의 카디널리티가 낮은 경우에 유용하다.
각각의 행의 상태를 비트맵으로 저장하여 대량의 데이터에 빠른 집계와 논리연산이 가능하다.

### 클러스터 인덱스(Clustered Index)

테이블의 데이터 자체를 정렬된 구조로 저장을 한다.
한 테이블에 하나만 생성할 수 있으며, 주로 기본키에 대해 설정이 된다.
데이터가 물리적으로 정렬되기 때문에 매우 빠른 데이터 접근이 가능하게 한다.

### 비클러스터드 인덱스 (Non-Clustered Index)

데이터와 인덱스를 별도로 저정한다.
여러 개를 생성할 수 있으며, 테이블 내 특정 컬럼에 대한 검색 성능을 향상시킨다.

## 장점

인덱스 사용으로 데이터 검색에 있어서 빠르게 결과를 얻을 수 있다. 기존에는 전체 데이터를 확인을 했지만 이제는 전체 데이터를 확인하지 않고 찾을 수 있으며
특히 `WHERE` `JOIN` `ORDER BY` `GROUP BY` 사용에 유용해졌다.
