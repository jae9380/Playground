#Algorithm #Sort
# 기본 정렬 알고리즘

알고리즘을 설명할 때 기본적으로 오름차순으로 정렬한다는 점을 기준으로 설명 한다.
## 선택 정렬 Selection Sort

### 동작 원리
해당 알고리즘의 동작 원리는 각 단계에서 가장 작은 원소를 찾아 앞으로 배치하는 동작을 통하여 배열을 정렬하게 된다. 

#### 원리

| 순서 \ 배열 | 7         | 4         | 5         | 1         | 3         |
|:-------:|:---------:|:---------:|:---------:|:---------:|:---------:|
| Step 1  | 1 (위치 이동) | 4         | 5         | 7 (위치 이동) | 3         |
| Step 2  | 1         | 3 (위치 이동) | 5         | 7         | 4 (위치 이동) |
| Step 3  | 1         | 3         | 4 (위치 이동) | 7         | 5 (위치 이동) |
| Step 4  | 1         | 3         | 4         | 5 (위치 이동) | 7 (위치 이동) |
* Step 1 
  최초 동작으로 배열을 순회하여 가장 작은 원소를 찾는다. 가장 작은 원소 찾고 배열을 모두 순회하여 이상으로 작은 값이 없는지 파악하고 가장 앞 요소와 위치를 변경한다.
* Step 2 
  다시 배열을 순회하여 다음으로 작은 원소를 찾아 가장 작은 원소 뒤에 해당 값을 옮긴다.

이러한 동작은 반복하여 배열을 오름 차순으로 정렬하게 된다.

### 시간 복잡도
해당 알고리즘읜 최악, 평균, 최선 모든 경우에서 동일한 결과를 나타낸다.
| 경우     | **비교 횟수**          | **교환 횟수** | **시간 복잡도** |
|:------:|:------------------:|:---------:|:----------:|
| 최선의 경우 | $\frac{n(n-1)}{2}$ | 최대 n - 1회 | $O(n^2)$   |
| 평균의 경우 | $\frac{n(n-1)}{2}$ | 최대 n - 1회 | $O(n^2)$   |
| 최악의 경우 | $\frac{n(n-1)}{2}$ | 최대 n - 1회 | $O(n^2)$   |

## 삽입 정렬 Insertion Sort

### 동작 원리

삽입 정렬은 **정렬되어 있는 부분과 아직 정렬되지 않은 부분을 나누어**, 정렬되지 않은 값을 **정렬된 위치에 삽입**하는 방식입니다.
이 과정은 배열이 거의 정렬되어 있을 경우 매우 효율적입니다.

#### 예시

| **순서 \ 배열** | **7**     | **4**     | **5**     | **1**     | **3**     |
|:-----------:|:---------:|:---------:|:---------:|:---------:|:---------:|
| Step 1      | 4 (위치 이동) | 7 (위치 이동) | 5         | 1         | 3         |
| Step 2      | 4         | 5 (위치 이동) | 7 (위치 이동) | 1         | 3         |
| Step 3      | 1 (위치 이동) | 4         | 5         | 7 (위치 이동) | 3         |
| Step 4      | 1         | 3 (위치 이동) | 4         | 5         | 7 (위치 이동) |

* Step 1
  두 번째 요소(4)를 기준으로 왼쪽(7)과 비교하여 올바른 위치에 삽입
* Step 2 
  세 번째 요소(5)를 정렬된 부분(4, 7)과 비교하여 삽입
* Step 3
  네 번째 요소(1)을 정렬된 부분(4, 5, 7)과 비교하여 삽입
* Step 4
  다섯 번째 요소(3)를 정렬된 부분(1, 4, 5, 7)과 비교하여 삽입

### 시간 복잡도
| **경우**             | **비교 횟수 (평균)**     | **이동 횟수 (최대)**     | **시간 복잡도** |
|:------------------:|:------------------:|:------------------:|:----------:|
| 최선의 경우 (이미 정렬된 경우) | $n - 1$            | $0$                | $O(n)$     |
| 평균의 경우             | 약 $\frac{n^2}{4}$  | 약 $\frac{n^2}{4}$  | $O(n^2)$   |
| 최악의 경우 (역순 정렬)     | $\frac{n(n-1)}{2}$ | $\frac{n(n-1)}{2}$ | $O(n^2)$   |


## 버블 정렬 Bubble Sort
### 동작 원리
버블 정렬 알고리즘의 동작은 아주 간단하다. 
특정 위치에서 인접한 두 원소의 값을 갖고 대소 비교를 통하여 위치를 조정하는 원리를 이용한다.

#### 예시

간단한 예시를 확인하기 전에 해당 알고리즘은 두 원소를 갖고 비교하여 위치를 이동한다는 것이 핵심 동작 원리이다.
| 순서 \ 배열 | 7         | 4         | 5         | 1         | 3         |
|:-------:|:---------:|:---------:|:---------:|:---------:|:---------:|
| Step 1  | 4 (위치 이동) | 7 (위치 이동) | 5         | 1         | 3         |
| Step 2  | 4         | 5 (위치 이동) | 7 (위치 이동) | 1         | 3         |
| Step 3  | 4         | 5         | 1 (위치 이동) | 7 (위치 이동) | 3         |
| Step 4  | 4         | 5         | 1         | 3 (위치 이동) | 7 (위치 이동) |
| Step 5  | 4         | 5         | 1         | 3         | 7         |
| Step 6  | 4         | 1 (위치 이동) | 5 (위치 이동) | 3         | 7         |

* 1회전 (Step 1 ~ 4)
  Step 1에서는 처음 인덱스와 다음 인덱스에 위치하고 있는 요소를 비교하여 적절한 위치로 옮기는 과정을 진행한다.  해당 과정을 배열 전체를 1회전 진행하면 배열의 가장 큰 값은 제일 마지막에 위치하게 된다.
* 2회전
  1회전과 동일한 원리로 마지막 원소 전까지만 인접 원소를 비교하면서 위치 이동을 해주면 된다. 그러면 두 번째로 큰 원소는 적절한 위치로 이동하게 된다.

해당 과정을 모든 원소가 적절한 위치로 이동할 때까지 동작을 반복하면 배열은 정렬이 된다.

### 장점과 단점 

* 장점 
  알고리즘 구현이 간단하다.
* 단점
  특정 원소를 최종 위치로 이동하기 위해서는 모든 다른 원소들과의 작업이 많이 발생한다.

### 시간 복잡도
해당 알고리즘은 외부 루프(i)는 0부터 n - 1까지, 내부 루프(j)는 0 부터 n - 1 - i까지 비교를 진행하게 된다.

$$n(n-1)\times2$$

교환 횟수는 최악인 상황에서는 모든 비교에서 교환이 된다. 그리고 교환 동작에서는 3개 대입  연산 동작을 하게 된다.

$$3n\times n(n-1)\div2$$

$$\therefore O(n^2)$$


1.**버블 정렬 ()**
* 인접한 두 값을 비교해가며 큰 값을 뒤로 보내는 방식
* 시간복잡도: **O(n²)**
* 구현은 쉽지만 성능은 좋지 않음
  2.**선택 정렬 ()**
  * 전체 리스트에서 **가장 작은 값을 선택**해 앞으로 보내는 방식
  * 시간복잡도: **O(n²)**
  * 교환 횟수가 적지만 느림
  3.**삽입 정렬 ()**
  * 이미 정렬된 부분에 **새 값을 끼워 넣는** 방식
  * 시간복잡도: **O(n²)**, 하지만 거의 정렬된 상태에선 **O(n)**